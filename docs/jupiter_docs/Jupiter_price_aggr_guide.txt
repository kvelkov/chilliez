Affected and New Files
Given your project's modular structure, the changes will be localized to a few key areas.

Affected Files:

src/arbitrage/orchestrator/detection_engine.rs: This is the core logic that will be modified to include the fallback. When the AdvancedPathFinder fails to find a profitable arbitrage path, the detection engine will call the Jupiter client to get a quote.
src/dex/clients/jupiter.rs: This file will be significantly updated. It will house the logic for interacting with the Jupiter V6 API to fetch quotes and build transactions.
src/config/settings.rs: You will need to add a new configuration flag to enable or disable the Jupiter fallback mechanism, e.g., jupiter_fallback_enabled: bool.
src/error/mod.rs: It would be good practice to add a new error variant to your ArbError enum for Jupiter-specific API failures, e.g., JupiterApiError(String).
New Files:

src/dex/clients/jupiter_api.rs (Recommended): To keep the code clean, I recommend creating this new file to define the request and response data structures for the Jupiter V6 API. This separates the API data model from the client logic.
tests/jupiter_fallback_test.rs: A new integration test file is essential to test the fallback logic end-to-end without affecting other integration tests.
2. Code Implementation and Testing
Hereâ€™s how you can build and test the feature.

Code Implementation
Step 1: Define Jupiter API Structures (in src/dex/clients/jupiter_api.rs)

First, define the structures for the Jupiter V6 /quote and /swap API endpoints. You'll need to use serde::{Deserialize, Serialize}.

Rust

// src/dex/clients/jupiter_api.rs

use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct QuoteRequest {
    pub input_mint: String,
    pub output_mint: String,
    pub amount: u64,
    pub slippage_bps: u16,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct QuoteResponse {
    pub out_amount: String,
    // Add other fields you need from the quote response
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SwapRequest {
    pub user_public_key: String,
    pub quote_response: QuoteResponse,
    // Add other fields for the swap request
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SwapResponse {
    pub swap_transaction: String, // Base64 encoded transaction
}
Step 2: Update the Jupiter Client (in src/dex/clients/jupiter.rs)

Modify the Jupiter client to include methods for getting quotes and creating swap transactions.

Rust

// src/dex/clients/jupiter.rs

use reqwest::Client;
use super::jupiter_api::{QuoteRequest, QuoteResponse, SwapRequest, SwapResponse};
// ... other imports

pub struct Jupiter {
    client: Client,
    api_url: String,
}

impl Jupiter {
    pub fn new(api_url: String) -> Self {
        Self {
            client: Client::new(),
            api_url,
        }
    }

    pub async fn get_quote(&self, request: QuoteRequest) -> Result<QuoteResponse, reqwest::Error> {
        self.client
            .post(format!("{}/v6/quote", self.api_url))
            .json(&request)
            .send()
            .await?
            .json()
            .await
    }
    
    // ... other methods to get swap transaction
}
Step 3: Modify the Detection Engine (in src/arbitrage/orchestrator/detection_engine.rs)

In the ArbitrageDetector, add the fallback logic.

Rust

// src/arbitrage/orchestrator/detection_engine.rs

// Inside your main detection loop...
let primary_opportunity = self.pathfinder.find_best_path(pools, start_token, end_token);

if let Some(opp) = primary_opportunity {
    // Proceed with primary opportunity
} else if self.settings.jupiter_fallback_enabled {
    // If no path found, and fallback is enabled, call Jupiter
    info!("Primary pathfinder found no opportunity. Trying Jupiter fallback.");
    let jupiter_quote = self.jupiter_client.get_quote(/* ... */).await;
    
    if let Ok(quote) = jupiter_quote {
        // ... Check if quote is profitable and create a transaction
    }
}
Testing Strategy
Unit Tests (in src/dex/clients/jupiter.rs):

Use a mocking library like mockito to create a mock Jupiter API server.
Write tests for get_quote to ensure that it correctly serializes the request and deserializes the mock response.
Integration Test (in tests/jupiter_fallback_test.rs):

Create a test that sets up a market scenario where your AdvancedPathFinder is guaranteed to fail (e.g., by providing disconnected pools).
Enable the jupiter_fallback_enabled setting for the test.
Mock the Jupiter API to return a profitable quote.
Assert that the bot correctly identifies the Jupiter-based opportunity and prepares a transaction for it.
3. Logging, Notifications, and Tests
Logging:

INFO: Log a message in detection_engine.rs every time the fallback to Jupiter is triggered. This is important for monitoring how often your primary strategy is being supplemented.
DEBUG: In jupiter.rs, log the request body sent to Jupiter and the response body received. This is invaluable for debugging API issues.
ERROR: In jupiter.rs, log any errors that occur when communicating with the Jupiter API (e.g., network errors, 5xx status codes).
Notifications:

Consider sending a notification (e.g., via a webhook) when the Jupiter fallback is used successfully. This can provide real-time insight into the bot's performance. You could also set up alerts for a high frequency of fallbacks, which might indicate an issue with your primary pool data feed.
Tests:

Specific Fallback Test: The new tests/jupiter_fallback_test.rs should have a test case that explicitly checks that the fallback is not triggered if a primary path is found.
Configuration Test: Add a test to verify that the fallback is not used if the jupiter_fallback_enabled flag is false.
Paper Trading: Add a scenario to your paper_trading_demo.rs that simulates market conditions where the Jupiter fallback would be activated, so you can observe its behavior in a realistic, simulated environment.