# QuickNode Stream Configuration
# Configuration for setting up real-time streams for arbitrage detection

# Stream subscriptions to set up
[streams]

# Account subscription for DEX program changes
[streams.dex_accounts]
enabled = true
method = "accountSubscribe"
addresses = [
    "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM",  # Orca Whirlpools
    "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",  # Raydium AMM
    "JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB",   # Jupiter
    "MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky",   # Meteora
    "2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c",  # Lifinity
]
options = { encoding = "base64", commitment = "finalized" }

# Log subscription for program interactions
[streams.program_logs]
enabled = true
method = "logsSubscribe"
filters = [
    { mentions = ["9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM"] },  # Orca
    { mentions = ["675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"] },  # Raydium
    { mentions = ["JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB"] },   # Jupiter
    { mentions = ["MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky"] },  # Meteora
    { mentions = ["2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c"] }   # Lifinity
]
options = { commitment = "finalized" }

# Signature subscription for specific transactions
[streams.signatures]
enabled = true
method = "signatureSubscribe"
# Add specific transaction signatures to monitor
signatures = []
options = { commitment = "finalized", enableReceivedNotification = false }

# Slot subscription for timing
[streams.slots]
enabled = true
method = "slotSubscribe"

# Root subscription for finalization
[streams.roots]
enabled = false
method = "rootSubscribe"

# Filter configuration
[filters]
# Minimum transaction value to process (in lamports)
min_transaction_value = 1000000  # 0.001 SOL

# Token mints to prioritize
priority_tokens = [
    "So11111111111111111111111111111111111111112",  # SOL
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", # USDC
    "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", # USDT
]

# DEX programs to monitor with priority levels
[filters.dex_priority]
"9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM" = 1  # Orca (highest)
"675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8" = 1  # Raydium (highest)
"JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB" = 2   # Jupiter (high)
"MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky" = 3   # Meteora (medium)
"2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c" = 3  # Lifinity (medium)

# Rate limiting
[rate_limiting]
max_messages_per_second = 100
max_subscriptions = 50
reconnect_delay_ms = 5000
max_reconnect_attempts = 10

# Monitoring and alerting
[monitoring]
enabled = true
log_level = "info"
metrics_enabled = true
health_check_interval_ms = 30000

# Alert thresholds
[monitoring.alerts]
high_volume_threshold = 1000  # transactions per minute
error_rate_threshold = 0.05   # 5% error rate
latency_threshold_ms = 100    # 100ms latency

# QuickNode specific settings
[quicknode]
api_version = "1.0"
max_response_size = "10MB"
compression = true

# Available QuickNode methods for reference
[quicknode.available_methods]
account_methods = [
    "getAccountInfo",
    "getBalance", 
    "getMultipleAccounts",
    "getProgramAccounts",
    "getTokenAccountBalance",
    "getTokenAccountsByDelegate",
    "getTokenAccountsByOwner"
]

block_methods = [
    "getBlock",
    "getBlockCommitment", 
    "getBlockHeight",
    "getBlocks",
    "getBlocksWithLimit",
    "getBlockTime",
    "getFirstAvailableBlock",
    "getLatestBlockhash"
]

transaction_methods = [
    "getTransaction",
    "getTransactionCount",
    "getSignatureStatuses",
    "getSignaturesForAddress",
    "simulateTransaction",
    "sendTransaction"
]

network_methods = [
    "getClusterNodes",
    "getEpochInfo",
    "getEpochSchedule", 
    "getGenesisHash",
    "getHealth",
    "getIdentity",
    "getSlot",
    "getSlotLeader",
    "getSlotLeaders",
    "getVersion",
    "minimumLedgerSlot"
]

token_methods = [
    "getTokenLargestAccounts",
    "getTokenSupply"
]

fee_methods = [
    "getFeeForMessage",
    "getRecentPrioritizationFees",
    "getMinimumBalanceForRentExemption"
]

validation_methods = [
    "isBlockhashValid",
    "requestAirdrop"
]

governance_methods = [
    "getInflationGovernor", 
    "getInflationRate",
    "getInflationReward",
    "getVoteAccounts",
    "getStakeMinimumDelegation"
]

supply_methods = [
    "getSupply",
    "getLargestAccounts"
]

performance_methods = [
    "getRecentPerformanceSamples",
    "getBlockProduction"
]

snapshot_methods = [
    "getHighestSnapshotSlot",
    "getMaxRetransmitSlot", 
    "getMaxShredInsertSlot"
]

parsed_methods = [
    "getParsedBlock",
    "getParsedTransaction"
]
